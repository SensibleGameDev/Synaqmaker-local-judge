{% extends "base.html" %}
{% block title %}üèÜ –¶–µ—Ä–µ–º–æ–Ω–∏—è —Ä–∞—Å–∫—Ä—ã—Ç–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤{% endblock %}

{% block content %}
<style>
    .reveal-container {
        max-width: 98%;
        margin: 0 auto;
        padding: 20px;
    }
    
    /* Scoreboard styles */
    .scoreboard-table {
        width: 100%;
        border-collapse: collapse;
        background: #1a1a2e;
        color: #fff;
        font-family: 'Segoe UI', system-ui, sans-serif;
    }
    
    .scoreboard-table th,
    .scoreboard-table td {
        padding: 12px 8px;
        text-align: center;
        border-bottom: 1px solid #333;
    }
    
    .scoreboard-table thead {
        background: #0f0f23;
        position: sticky;
        top: 0;
        z-index: 100;
    }
    
    .scoreboard-table thead th {
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 1px;
        font-size: 0.85em;
        color: #a0a0c0;
    }
    
    .scoreboard-row {
        transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
    }
    
    .scoreboard-row:hover {
        background: #252545 !important;
    }
    
    /* Rank badges */
    .rank-cell {
        font-size: 1.3em;
        font-weight: bold;
        width: 60px;
    }
    
    .rank-1 { color: #ffd700; }
    .rank-2 { color: #c0c0c0; }
    .rank-3 { color: #cd7f32; }
    
    /* Nickname cell */
    .nickname-cell {
        text-align: left !important;
        font-weight: 600;
        font-size: 1.1em;
    }
    
    .org-cell {
        text-align: left !important;
        color: #888;
        font-size: 0.9em;
    }
    
    /* Task score cells */
    .task-cell {
        min-width: 60px;
        font-family: 'Consolas', monospace;
        font-weight: bold;
        border-radius: 4px;
        margin: 2px;
    }
    
    .task-solved {
        background: #28a745 !important;
        color: #fff;
    }
    
    .task-failed {
        background: #dc3545 !important;
        color: #fff;
    }
    
    .task-pending {
        background: #ffc107 !important;
        color: #000;
        animation: pulse-pending 1.5s infinite;
    }
    
    @keyframes pulse-pending {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.6; }
    }
    
    /* Reveal animation */
    .revealing {
        background: linear-gradient(90deg, #ffc107 0%, #ff9800 50%, #ffc107 100%);
        background-size: 200% 100%;
        animation: shimmer 1.5s ease-in-out;
        color: #000;
    }
    
    @keyframes shimmer {
        0% { background-position: 200% 0; }
        100% { background-position: -200% 0; }
    }
    
    .reveal-success {
        animation: flashGreen 1s ease-out;
    }
    
    @keyframes flashGreen {
        0% { background-color: rgba(40, 167, 69, 0.9); }
        100% { background-color: transparent; }
    }
    
    .reveal-fail {
        animation: flashRed 1s ease-out;
    }
    
    @keyframes flashRed {
        0% { background-color: rgba(220, 53, 69, 0.9); }
        100% { background-color: transparent; }
    }
    
    /* Row movement animation */
    .moving-up {
        animation: moveUp 0.8s ease-out;
    }
    
    @keyframes moveUp {
        0% { transform: translateY(50px); opacity: 0.7; }
        100% { transform: translateY(0); opacity: 1; }
    }
    
    /* Focus highlight for current row being revealed */
    .focus-row {
        background: #2a2a5a !important;
        box-shadow: 0 0 20px rgba(255, 193, 7, 0.5);
        transform: scale(1.02);
        z-index: 50;
    }
    
    /* Control panel */
    .control-panel {
        background: #1a1a2e;
        padding: 20px;
        border-radius: 10px;
        margin-bottom: 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 15px;
        transition: all 0.3s ease;
        position: relative;
    }
    
    .control-panel.hidden {
        transform: translateY(-100%);
        opacity: 0;
        pointer-events: none;
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        z-index: -1;
    }
    
    .toggle-controls-btn {
        position: fixed;
        top: 10px;
        right: 10px;
        z-index: 1001;
        background: rgba(26, 26, 46, 0.9);
        color: #fff;
        border: 2px solid #ffc107;
        padding: 10px 15px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 1.1em;
        transition: all 0.3s;
    }
    
    .toggle-controls-btn:hover {
        background: rgba(255, 193, 7, 0.2);
        transform: scale(1.05);
    }
    
    .reveal-container.fullscreen {
        max-width: 100%;
        padding: 10px;
    }
    
    .reveal-container.fullscreen .scoreboard-table {
        font-size: 1.2em;
    }
    
    .control-btn {
        padding: 12px 24px;
        font-size: 1.1em;
        border-radius: 8px;
        border: none;
        cursor: pointer;
        transition: all 0.3s;
    }
    
    .btn-reveal {
        background: linear-gradient(135deg, #ffc107 0%, #ff9800 100%);
        color: #000;
        font-weight: bold;
    }
    
    .btn-reveal:hover {
        transform: scale(1.05);
        box-shadow: 0 4px 15px rgba(255, 193, 7, 0.4);
    }
    
    .btn-skip {
        background: #6c757d;
        color: #fff;
    }
    
    .btn-auto {
        background: #28a745;
        color: #fff;
    }
    
    /* Progress indicator */
    .progress-indicator {
        color: #a0a0c0;
        font-size: 0.9em;
    }
    
    /* Winner celebration */
    .winner-banner {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, #ffd700 0%, #ff9800 50%, #ffd700 100%);
        padding: 40px 60px;
        border-radius: 20px;
        z-index: 1000;
        text-align: center;
        box-shadow: 0 0 50px rgba(255, 215, 0, 0.8);
        animation: winnerAppear 0.5s ease-out;
    }
    
    @keyframes winnerAppear {
        0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
        100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    }
    
    .winner-banner h1 {
        color: #1a1a2e;
        font-size: 2.5em;
        margin-bottom: 10px;
    }
    
    .winner-banner .winner-name {
        font-size: 3em;
        font-weight: bold;
        color: #000;
    }
    
    /* Medal emoji sizes */
    .medal-gold::before { content: 'ü•á'; font-size: 3em; }
    .medal-silver::before { content: 'ü•à'; font-size: 3em; }
    .medal-bronze::before { content: 'ü•â'; font-size: 3em; }
    
    /* Overlay for winner announcement */
    .overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        z-index: 999;
    }
    
    /* Speed control */
    .speed-control {
        display: flex;
        align-items: center;
        gap: 10px;
        color: #fff;
    }
    
    .speed-slider {
        width: 150px;
    }
    
    /* Diploma announcement banner */
    .diploma-banner {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, #1a1a3e 0%, #2a2a5a 100%);
        padding: 60px 80px;
        border-radius: 20px;
        z-index: 1001;
        text-align: center;
        box-shadow: 0 0 60px rgba(255, 215, 0, 0.6);
        animation: diplomaAppear 0.6s ease-out;
        border: 3px solid #ffd700;
        min-width: 600px;
    }
    
    @keyframes diplomaAppear {
        0% { transform: translate(-50%, -50%) scale(0) rotate(-5deg); opacity: 0; }
        60% { transform: translate(-50%, -50%) scale(1.05) rotate(0deg); opacity: 1; }
        100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); opacity: 1; }
    }
    
    .diploma-banner .diploma-degree {
        font-size: 2.5em;
        font-weight: 900;
        color: #ffd700;
        text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        margin-bottom: 20px;
        letter-spacing: 3px;
    }
    
    .diploma-banner .diploma-nickname {
        font-size: 3.5em;
        font-weight: bold;
        color: #ffffff;
        margin: 20px 0;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    }
    
    .diploma-banner .diploma-organization {
        font-size: 1.5em;
        color: #aaaaaa;
        margin-top: 10px;
    }
    
    .diploma-banner .diploma-medal {
        font-size: 5em;
        margin-bottom: 20px;
    }
    
    .diploma-banner .first-to-solve {
        margin-top: 30px;
        padding: 15px 25px;
        background: rgba(40, 167, 69, 0.3);
        border: 2px solid #28a745;
        border-radius: 10px;
        font-size: 1.3em;
        color: #4ade80;
        font-weight: 600;
        display: inline-block;
    }
    
    .diploma-banner .first-to-solve i {
        color: #ffd700;
    }

</style>

<!-- Toggle controls button -->
<button class="toggle-controls-btn" onclick="toggleControls()" id="toggle-controls-btn">
    <i class="bi bi-chevron-up"></i> Hide Controls
</button>

<div class="reveal-container" id="reveal-container">
    <div class="text-center mb-4">
        <h1 class="display-4 text-white">üèÜ ICPC World Finals Style Reveal</h1>
        <p class="lead text-muted">–û–ª–∏–º–ø–∏–∞–¥–∞: {{ olympiad_id }}</p>
    </div>
    
    <div class="control-panel">
        <div class="d-flex gap-3 flex-wrap">
            <button id="btn-reveal-next" class="control-btn btn-reveal" onclick="revealNext()">
                <i class="bi bi-play-fill"></i> –†–∞—Å–∫—Ä—ã—Ç—å —Å–ª–µ–¥—É—é—â–∏–π
            </button>
            <button id="btn-auto-reveal" class="control-btn btn-auto" onclick="startAutoReveal()">
                <i class="bi bi-fast-forward-fill"></i> –ê–≤—Ç–æ —Ä–∞—Å–∫—Ä—ã—Ç–∏–µ
            </button>
            <button id="btn-stop-auto" class="control-btn btn-skip d-none" onclick="stopAutoReveal()">
                <i class="bi bi-pause-fill"></i> –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å
            </button>
            <button id="btn-skip-to-end" class="control-btn btn-skip" onclick="skipToEnd()">
                <i class="bi bi-skip-end-fill"></i> –ü–æ–∫–∞–∑–∞—Ç—å –∏—Ç–æ–≥
            </button>
        </div>
        
        <div class="speed-control">
            <label for="speed-slider">–°–∫–æ—Ä–æ—Å—Ç—å:</label>
            <input type="range" id="speed-slider" class="speed-slider" min="500" max="3000" value="1500" step="100">
            <span id="speed-value">1.5s</span>
        </div>
        
        <div class="progress-indicator">
            <span id="reveal-progress">–û–∂–∏–¥–∞–Ω–∏–µ –Ω–∞—á–∞–ª–∞...</span>
        </div>
    </div>
    
    <div class="card bg-dark">
        <div class="card-body p-0">
            <div class="table-responsive">
                <table class="scoreboard-table" id="scoreboard">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th style="text-align: left;">–£—á–∞—Å—Ç–Ω–∏–∫</th>
                            <th style="text-align: left;">–û—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—è</th>
                            {% set letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' %}
                            {% for task in tasks %}
                            <th>{{ letters[loop.index0] }}</th>
                            {% endfor %}
                            <th>–†–µ—à–µ–Ω–æ</th>
                            <th>–®—Ç—Ä–∞—Ñ</th>
                        </tr>
                    </thead>
                    <tbody id="scoreboard-body">
                    </tbody>
                </table>
            </div>
        </div>
    </div>
    
    <div class="mt-4 text-center">
        <a href="{{ url_for('olympiad_end', olympiad_id=olympiad_id) }}" class="btn btn-outline-light">
            <i class="bi bi-arrow-left"></i> –í–µ—Ä–Ω—É—Ç—å—Å—è –∫ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º
        </a>
        <a href="{{ url_for('api_export_frozen', olympiad_id=olympiad_id) }}" class="btn btn-outline-info">
            <i class="bi bi-download"></i> –≠–∫—Å–ø–æ—Ä—Ç JSON
        </a>
        <button onclick="showWinners()" class="btn btn-warning">
            <i class="bi bi-trophy-fill"></i> –ü–æ–∫–∞–∑–∞—Ç—å –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π
        </button>
    </div>
</div>

<div class="overlay" id="overlay"></div>
<div class="winner-banner" id="winner-banner">
    <div id="winner-medal"></div>
    <h1 id="winner-place"></h1>
    <div class="winner-name" id="winner-name"></div>
    <div id="winner-org" class="text-muted mt-2"></div>
    <button class="btn btn-dark mt-3" onclick="hideWinnerBanner()">–ó–∞–∫—Ä—ã—Ç—å</button>
</div>

<!-- Diploma announcement banner -->
<div class="diploma-banner" id="diploma-banner">
    <div class="diploma-medal" id="diploma-medal"></div>
    <div class="diploma-degree" id="diploma-degree"></div>
    <div class="diploma-nickname" id="diploma-nickname"></div>
    <div class="diploma-organization" id="diploma-organization"></div>
    <div class="first-to-solve" id="diploma-first-solve" style="display: none;">
        <i class="bi bi-lightning-fill"></i> <span id="first-solve-text"></span>
    </div>
</div>

<script>
    // Data from server
    const frozenScoreboard = {{ frozen_scoreboard | tojson | safe }};
    const finalScoreboard = {{ final_scoreboard | tojson | safe }};
    const taskIds = [{% for task in tasks %}{{ task[0] }}{% if not loop.last %}, {% endif %}{% endfor %}];
    const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    const firstSolvers = {{ first_solvers | tojson | safe }};
    const winners = {{ winners | tojson | safe }};
    
    // State
    let currentBoard = JSON.parse(JSON.stringify(frozenScoreboard)); // Deep copy
    let revealQueue = [];
    let autoRevealInterval = null;
    let isRevealing = false;
    let revealedCount = 0;
    let totalToReveal = 0;
    
    // Initialize reveal queue by finding pending submissions
    function initRevealQueue() {
        revealQueue = [];
        
        // Compare frozen and final to find differences
        const frozenMap = new Map(frozenScoreboard.map(p => [p.participant_id, p]));
        const finalMap = new Map(finalScoreboard.map(p => [p.participant_id, p]));
        
        // Process from bottom of standings up (ICPC style)
        const sortedFrozen = [...frozenScoreboard].reverse();
        
        sortedFrozen.forEach(frozenP => {
            const finalP = finalMap.get(frozenP.participant_id);
            if (!finalP) return;
            
            // Check each task for changes
            taskIds.forEach(taskId => {
                const taskKey = String(taskId);
                const frozenTask = frozenP.scores[taskKey] || {};
                const finalTask = finalP.scores[taskKey] || {};
                
                // If task was pending (had attempts but not passed in frozen, but has result in final)
                const frozenPassed = frozenTask.passed || false;
                const finalPassed = finalTask.passed || false;
                const frozenAttempts = frozenTask.attempts || 0;
                const finalAttempts = finalTask.attempts || 0;
                
                // Detect changes that happened during freeze
                if (finalAttempts > frozenAttempts || (finalPassed && !frozenPassed)) {
                    revealQueue.push({
                        participant_id: frozenP.participant_id,
                        task_id: taskId,
                        frozenData: frozenTask,
                        finalData: finalTask,
                        nickname: frozenP.nickname
                    });
                }
            });
        });
        
        totalToReveal = revealQueue.length;
        updateProgress();
    }
    
    // Render scoreboard
    function renderScoreboard() {
        const tbody = document.getElementById('scoreboard-body');
        tbody.innerHTML = '';
        
        // Sort current board
        currentBoard.sort((a, b) => {
            if (b.total_score !== a.total_score) return b.total_score - a.total_score;
            return a.total_penalty - b.total_penalty;
        });
        
        currentBoard.forEach((participant, index) => {
            const rank = index + 1;
            const tr = document.createElement('tr');
            tr.className = 'scoreboard-row';
            tr.dataset.participantId = participant.participant_id;
            
            // Rank cell
            let rankClass = '';
            let rankContent = rank;
            if (rank === 1) { rankClass = 'rank-1'; rankContent = 'ü•á'; }
            else if (rank === 2) { rankClass = 'rank-2'; rankContent = 'ü•à'; }
            else if (rank === 3) { rankClass = 'rank-3'; rankContent = 'ü•â'; }
            
            let tasksHtml = '';
            taskIds.forEach(taskId => {
                const taskKey = String(taskId);
                const taskData = participant.scores[taskKey] || {};
                let cellClass = 'task-cell';
                let cellContent = '.';
                
                // Check if this task is pending (has attempts in frozen but changed in final)
                const finalP = finalScoreboard.find(p => p.participant_id === participant.participant_id);
                const finalTask = finalP ? (finalP.scores[taskKey] || {}) : {};
                const isPending = (finalTask.attempts || 0) > (taskData.attempts || 0) || 
                                 (finalTask.passed && !taskData.passed);
                
                if (taskData.passed) {
                    cellClass += ' task-solved';
                    cellContent = `+${taskData.attempts > 0 ? taskData.attempts : ''}`;
                } else if (isPending) {
                    cellClass += ' task-pending';
                    cellContent = '?';
                } else if (taskData.attempts > 0) {
                    cellClass += ' task-failed';
                    cellContent = `-${taskData.attempts}`;
                }
                
                tasksHtml += `<td class="${cellClass}" data-task="${taskId}">${cellContent}</td>`;
            });
            
            tr.innerHTML = `
                <td class="rank-cell ${rankClass}">${rankContent}</td>
                <td class="nickname-cell">${participant.nickname}</td>
                <td class="org-cell">${participant.organization || '-'}</td>
                ${tasksHtml}
                <td class="text-success fw-bold">${participant.total_score}</td>
                <td class="text-secondary">${participant.total_penalty}</td>
            `;
            
            tbody.appendChild(tr);
        });
    }
    
    // Reveal next pending submission
    async function revealNext() {
        if (isRevealing || revealQueue.length === 0) return;
        
        isRevealing = true;
        const reveal = revealQueue.shift();
        revealedCount++;
        updateProgress();
        
        // Find the row and cell
        const row = document.querySelector(`tr[data-participant-id="${reveal.participant_id}"]`);
        const cell = row ? row.querySelector(`td[data-task="${reveal.task_id}"]`) : null;
        
        if (row && cell) {
            // Focus on row
            row.classList.add('focus-row');
            row.scrollIntoView({ behavior: 'smooth', block: 'center' });
            
            // Add revealing animation to cell
            cell.classList.add('revealing');
            
            await sleep(getSpeed() / 2);
            
            // Update the cell with final result
            const finalData = reveal.finalData;
            cell.classList.remove('revealing', 'task-pending');
            
            if (finalData.passed) {
                cell.classList.add('task-solved', 'reveal-success');
                cell.textContent = `+${finalData.attempts > 0 ? finalData.attempts : ''}`;
            } else if (finalData.attempts > 0) {
                cell.classList.add('task-failed', 'reveal-fail');
                cell.textContent = `-${finalData.attempts}`;
            }
            
            // Update the participant data in currentBoard
            const participant = currentBoard.find(p => p.participant_id === reveal.participant_id);
            if (participant) {
                participant.scores[String(reveal.task_id)] = finalData;
                
                // Recalculate totals
                let totalScore = 0;
                let totalPenalty = 0;
                Object.values(participant.scores).forEach(s => {
                    if (s.passed) {
                        totalScore++;
                        totalPenalty += s.penalty || 0;
                    }
                });
                participant.total_score = totalScore;
                participant.total_penalty = totalPenalty;
            }
            
            await sleep(getSpeed() / 2);
            
            // Remove focus and re-render (with position changes)
            row.classList.remove('focus-row');
            const previousRank = getCurrentRank(reveal.participant_id);
            renderScoreboard();
            const newRank = getCurrentRank(reveal.participant_id);
            
            // Check if this participant earned a diploma and if there are no more reveals for them
            const hasMoreReveals = revealQueue.some(r => r.participant_id === reveal.participant_id);
            if (!hasMoreReveals && newRank <= 6) {
                // Check if they earned a diploma
                const diplomaInfo = getDiplomaForParticipant(reveal.participant_id);
                if (diplomaInfo) {
                    // Check if participant is first to solve this problem
                    const isFirstToSolve = finalData.passed && firstSolvers[String(reveal.task_id)] === reveal.participant_id;
                    await showDiplomaBanner(diplomaInfo, participant, reveal.task_id, isFirstToSolve);
                }
            }
        }
        
        isRevealing = false;
        
        // Check if reveal is complete
        if (revealQueue.length === 0) {
            document.getElementById('reveal-progress').textContent = '‚úì –†–∞—Å–∫—Ä—ã—Ç–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ!';
            stopAutoReveal();
        }
    }
    
    // Auto reveal mode
    function startAutoReveal() {
        if (autoRevealInterval) return;
        
        document.getElementById('btn-auto-reveal').classList.add('d-none');
        document.getElementById('btn-stop-auto').classList.remove('d-none');
        
        autoRevealInterval = setInterval(() => {
            if (revealQueue.length > 0 && !isRevealing) {
                revealNext();
            } else if (revealQueue.length === 0) {
                stopAutoReveal();
            }
        }, getSpeed());
    }
    
    function stopAutoReveal() {
        if (autoRevealInterval) {
            clearInterval(autoRevealInterval);
            autoRevealInterval = null;
        }
        document.getElementById('btn-auto-reveal').classList.remove('d-none');
        document.getElementById('btn-stop-auto').classList.add('d-none');
    }
    
    // Skip to end - show final results immediately
    function skipToEnd() {
        stopAutoReveal();
        currentBoard = JSON.parse(JSON.stringify(finalScoreboard));
        revealQueue = [];
        renderScoreboard();
        document.getElementById('reveal-progress').textContent = '‚úì –ü–æ–∫–∞–∑–∞–Ω—ã –∏—Ç–æ–≥–æ–≤—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã';
    }
    
    // Helper: Get current rank of participant
    function getCurrentRank(participantId) {
        const sorted = [...currentBoard].sort((a, b) => {
            if (b.total_score !== a.total_score) return b.total_score - a.total_score;
            return a.total_penalty - b.total_penalty;
        });
        return sorted.findIndex(p => p.participant_id === participantId) + 1;
    }
    
    // Helper: Get diploma info for participant based on rank
    function getDiplomaForParticipant(participantId) {
        const rank = getCurrentRank(participantId);
        
        // 1st place = First Degree Diploma (Gold)
        if (rank === 1) {
            return { degree: 'FIRST DEGREE DIPLOMA', medal: 'ü•á', place: 1 };
        }
        // 2nd and 3rd place = Second Degree Diploma (Silver)
        else if (rank >= 2 && rank <= 3) {
            return { degree: 'SECOND DEGREE DIPLOMA', medal: 'ü•à', place: 2 };
        }
        // 4th, 5th, 6th place = Third Degree Diploma (Bronze)
        else if (rank >= 4 && rank <= 6) {
            return { degree: 'THIRD DEGREE DIPLOMA', medal: 'ü•â', place: 3 };
        }
        
        return null;
    }
    
    // Show diploma banner with participant info
    async function showDiplomaBanner(diplomaInfo, participant, taskId, isFirstToSolve) {
        const overlay = document.getElementById('overlay');
        const banner = document.getElementById('diploma-banner');
        const medalEl = document.getElementById('diploma-medal');
        const degreeEl = document.getElementById('diploma-degree');
        const nicknameEl = document.getElementById('diploma-nickname');
        const orgEl = document.getElementById('diploma-organization');
        const firstSolveEl = document.getElementById('diploma-first-solve');
        const firstSolveText = document.getElementById('first-solve-text');
        
        // Set diploma content
        medalEl.textContent = diplomaInfo.medal;
        degreeEl.textContent = diplomaInfo.degree;
        nicknameEl.textContent = participant.nickname;
        orgEl.textContent = participant.organization || '';
        
        // Show first to solve if applicable
        if (isFirstToSolve) {
            const taskIndex = taskIds.indexOf(taskId);
            const problemLetter = letters[taskIndex];
            firstSolveText.textContent = `FIRST TO SOLVE PROBLEM ${problemLetter}`;
            firstSolveEl.style.display = 'inline-block';
        } else {
            firstSolveEl.style.display = 'none';
        }
        
        // Show banner
        overlay.style.display = 'block';
        banner.style.display = 'block';
        
        // Auto-hide after 3 seconds
        await sleep(3000);
        overlay.style.display = 'none';
        banner.style.display = 'none';
    }
    
    // Show winners announcement
    async function showWinners() {
        const response = await fetch(`/olympiad/api/winners/{{ olympiad_id }}`);
        const data = await response.json();
        
        if (data.error) {
            alert(data.error);
            return;
        }
        
        const winners = data.winners;
        
        // Show each place with animation
        for (let place of [3, 2, 1]) {
            if (winners[place] && winners[place].length > 0) {
                for (const winner of winners[place]) {
                    await showWinnerBanner(place, winner);
                    await sleep(3000);
                    hideWinnerBanner();
                    await sleep(500);
                }
            }
        }
    }
    
    function showWinnerBanner(place, winner) {
        return new Promise(resolve => {
            const overlay = document.getElementById('overlay');
            const banner = document.getElementById('winner-banner');
            const medal = document.getElementById('winner-medal');
            const placeEl = document.getElementById('winner-place');
            const nameEl = document.getElementById('winner-name');
            const orgEl = document.getElementById('winner-org');
            
            medal.className = '';
            if (place === 1) medal.className = 'medal-gold';
            else if (place === 2) medal.className = 'medal-silver';
            else if (place === 3) medal.className = 'medal-bronze';
            
            const placeNames = {
                1: 'FIRST DEGREE DIPLOMA',
                2: 'SECOND DEGREE DIPLOMA',
                3: 'THIRD DEGREE DIPLOMA'
            };
            
            placeEl.textContent = placeNames[place];
            nameEl.textContent = winner.nickname;
            orgEl.textContent = winner.organization || '';
            
            overlay.style.display = 'block';
            banner.style.display = 'block';
            
            setTimeout(resolve, 100);
        });
    }
    
    function hideWinnerBanner() {
        document.getElementById('overlay').style.display = 'none';
        document.getElementById('winner-banner').style.display = 'none';
    }
    
    // Utility functions
    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    function getSpeed() {
        return parseInt(document.getElementById('speed-slider').value);
    }
    
    function updateProgress() {
        const remaining = revealQueue.length;
        document.getElementById('reveal-progress').textContent = 
            `–†–∞—Å–∫—Ä—ã—Ç–æ: ${revealedCount} / ${totalToReveal} (–æ—Å—Ç–∞–ª–æ—Å—å: ${remaining})`;
    }
    
    // Speed slider
    document.getElementById('speed-slider').addEventListener('input', function() {
        document.getElementById('speed-value').textContent = (this.value / 1000).toFixed(1) + 's';
        
        // Restart auto reveal with new speed if active
        if (autoRevealInterval) {
            stopAutoReveal();
            startAutoReveal();
        }
    });
    
    // Toggle controls visibility
    let controlsHidden = false;
    function toggleControls() {
        const controlPanel = document.querySelector('.control-panel');
        const toggleBtn = document.getElementById('toggle-controls-btn');
        const container = document.getElementById('reveal-container');
        
        controlsHidden = !controlsHidden;
        
        if (controlsHidden) {
            controlPanel.classList.add('hidden');
            toggleBtn.innerHTML = '<i class="bi bi-chevron-down"></i> Show Controls';
            container.classList.add('fullscreen');
        } else {
            controlPanel.classList.remove('hidden');
            toggleBtn.innerHTML = '<i class="bi bi-chevron-up"></i> Hide Controls';
            container.classList.remove('fullscreen');
        }
    }
    
    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
        // Don't intercept keys if user is typing in an input
        const activeElement = document.activeElement;
        const isTyping = activeElement && (
            activeElement.tagName === 'INPUT' || 
            activeElement.tagName === 'TEXTAREA' ||
            activeElement.isContentEditable
        );
        
        if (e.key === 'h' || e.key === 'H') {
            toggleControls();
        } else if ((e.key === ' ' || e.key === 'ArrowRight') && !isTyping) {
            e.preventDefault();
            revealNext();
        } else if (e.key === 'a' || e.key === 'A') {
            startAutoReveal();
        } else if (e.key === 's' || e.key === 'S') {
            stopAutoReveal();
        }
    });
    
    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
        initRevealQueue();
        renderScoreboard();
    });
</script>
{% endblock %}
